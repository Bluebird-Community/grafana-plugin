{"version":3,"sources":["../../../src/datasources/perf-ds/function_formatter.js"],"names":["FUNCTION_MATCH","ARGUMENT_MATCH","FunctionFormatter","label","match","ret","exec","args","getArguments","push","name","arguments","argsString","trim","length","split","Array","isArray","replacements","func","hasOwnProperty","result","apply","replace","console","warn","metadata","nodeToLabel","nodeCriteria","node","_getNodeFromCriteria","resourceToLabel","criteriaOrResourceId","partialResourceId","resource","_getResource","join","resourceToName","resourceToInterface","nodeId","foreignSource","foreignId","indexOf","parseInt","_getNodeFromMetadata","nodes","filter","undefined","id","resources","_getResourceFromCriteria","resourceCriteria","nodeCriterias","map","c","criteria"],"mappings":"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","file":"function_formatter.js","sourcesContent":["const FUNCTION_MATCH = /(\\w+)\\(([^\\)]*)\\)/g;\nconst ARGUMENT_MATCH = /\\s*,\\s*/;\n\nexport class FunctionFormatter {\n    static findFunctions(label) {\n        let match, ret = [];\n        while ((match = FUNCTION_MATCH.exec(label)) !== null) {\n            const args = FunctionFormatter.getArguments(match[2]);\n            ret.push({\n                name: match[1],\n                arguments: FunctionFormatter.getArguments(match[2])\n            });\n        }\n        return ret;\n    }\n\n    static getArguments(args) {\n        const argsString = args === null? '' : args.trim();\n        if (argsString.length === 0) {\n            return [];\n        }\n        const split = argsString.split(ARGUMENT_MATCH);\n        return Array.isArray(split) ? split : [split];\n    }\n\n    static replace(label, replacements) {\n        let match;\n        let ret = label;\n        while ((match = FUNCTION_MATCH.exec(label)) !== null) {\n            const func = match[1],\n                args = FunctionFormatter.getArguments(match[2]);\n            if (replacements.hasOwnProperty(func)) {\n                const result = replacements[func].apply(replacements[func], args);\n                ret = ret.replace(match[0], result);\n            } else {\n                console.warn('LabelFormatter.replace: unhandled function ' + func);\n            }\n        }\n        return ret;\n    }\n    static format(label, metadata) {\n        return FunctionFormatter.replace(label, {\n            nodeToLabel: (nodeCriteria) => {\n                const node = FunctionFormatter._getNodeFromCriteria(metadata, nodeCriteria);\n                if (node) {\n                    return node.label;\n                }\n                return nodeCriteria;\n            },\n            resourceToLabel: (criteriaOrResourceId, partialResourceId) => {\n                const resource = FunctionFormatter._getResource(metadata, criteriaOrResourceId, partialResourceId);\n                if (resource) {\n                    return resource.label;\n                }\n                return partialResourceId ? [criteriaOrResourceId, partialResourceId].join('.') : criteriaOrResourceId;\n            },\n            resourceToName: (criteriaOrResourceId, partialResourceId) => {\n                const resource = FunctionFormatter._getResource(metadata, criteriaOrResourceId, partialResourceId);\n                if (resource) {\n                    return resource.name;\n                }\n                return partialResourceId ? [criteriaOrResourceId, partialResourceId].join('.') : criteriaOrResourceId;\n            },\n            resourceToInterface: (criteriaOrResourceId, partialResourceId) => {\n                const resource = FunctionFormatter._getResource(metadata, criteriaOrResourceId, partialResourceId);\n                if (resource) {\n                    let match = resource.name.match(/^(\\w+)/);\n                    if (!match) {\n                        match = resource.label.match(/^(\\w+)/);\n                    }\n                    if (match) {\n                        return match[1];\n                    }\n                }\n                return partialResourceId ? [criteriaOrResourceId, partialResourceId].join('.') : criteriaOrResourceId;\n            }\n        });\n    }\n\n    static _getNodeFromCriteria(metadata, nodeCriteria) {\n        let nodeId, foreignSource, foreignId;\n        if (nodeCriteria && nodeCriteria.indexOf(':') > 0) {\n            [foreignSource, foreignId] = nodeCriteria.split(':');\n        } else {\n            nodeId = parseInt(nodeCriteria, 10);\n        }\n        return FunctionFormatter._getNodeFromMetadata(metadata, nodeId, foreignSource, foreignId);\n    }\n\n    static _getNodeFromMetadata(metadata, nodeId, foreignSource, foreignId) {\n        if (metadata && metadata.nodes) {\n            const ret = metadata.nodes.filter((node) => {\n                return (nodeId !== undefined && node.id === nodeId) ||\n                (foreignSource !== undefined && foreignId !== undefined &&\n                    node['foreign-source'] === foreignSource && node['foreign-id'] === foreignId);\n            })[0];\n            if (ret !== undefined) {\n                return ret;\n            }\n        }\n        //console.warn('Unable to locate node ' + [nodeId, foreignSource, foreignId].join(',') + ' in metadata.', metadata);\n        return null;\n    }\n\n    static _getResource(metadata, criteriaOrResourceId, partialResourceId) {\n        if (partialResourceId === undefined) {\n            for (const resource of metadata.resources) {\n                if (resource.id === criteriaOrResourceId) {\n                    return resource;\n                }\n            }\n        } else {\n            const node = FunctionFormatter._getNodeFromCriteria(metadata, criteriaOrResourceId);\n            if (node) {\n                const resource = FunctionFormatter._getResourceFromCriteria(metadata, partialResourceId, 'node[' + node['foreign-source'] + ':' + node['foreign-id'] + ']', 'node[' + node.id + ']');\n                if (resource) {\n                    return resource;\n                }\n            }\n        }\n        //console.warn('Unable to locate resource ' + [criteriaOrResourceId,partialResourceId].join('.') + ' in metadata.', metadata);\n        return null;\n    }\n\n    static _getResourceFromCriteria(metadata, resourceCriteria, ...nodeCriterias) {\n        if (metadata && metadata.resources) {\n            const ret = metadata.resources.filter((resource) => {\n                if (resource.id === resourceCriteria) return true;\n                for (const criteria of nodeCriterias.map(c => c + '.' + resourceCriteria)) {\n                    if (resource.id === criteria) {\n                        return true;\n                    }\n                }\n                return false;\n            })[0];\n            if (ret !== undefined) {\n                return ret;\n            }\n        }\n        //console.warn('Unable to locate resource ' + resourceCriteria + ' in metadata.', metadata);\n        return null;\n    }\n}"]}