{"version":3,"sources":["../../../src/datasources/perf-ds/function_formatter.js"],"names":["parse","ARGUMENT_MATCH","isString","value","String","getLast","arr","Array","isArray","length","undefined","FunctionFormatter","label","_process","brackets","parenthesized","parenthesize","map","entry","arguments","getArguments","console","log","parenthesizeWithArguments","filter","name","args","argsString","split","replacements","ret","forEach","token","hasOwnProperty","apply","join","metadata","replace","nodeToLabel","nodeCriteria","node","_getNodeFromCriteria","resourceToLabel","criteriaOrResourceId","partialResourceId","resource","_getResource","resourceToName","resourceToInterface","match","matcher","skip","arg","index","prev","next","push","exec","prefix","startsWith","replacement","_flatten","result","res","trim","Error","nodeId","foreignSource","foreignId","indexOf","parseInt","_getNodeFromMetadata","nodes","id","resources","_getResourceFromCriteria","resourceCriteria","nodeCriterias","c","criteria"],"mappings":"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","file":"function_formatter.js","sourcesContent":["const ARGUMENT_MATCH = /\\s*,\\s*/;\n\nimport parse from '../../parenthesis/index';\n\nconst isString = (value) => {\n    return typeof value === 'string' || value instanceof String;\n};\n\nconst getLast = (arr) => {\n    if (arr) {\n        if (Array.isArray(arr) && arr.length > 0) {\n            return arr[arr.length - 1];\n        }\n    }\n    return undefined;\n};\n\nexport class FunctionFormatter {\n    /**\n     * Convert the provided label into an array containing a mix of string values\n     * and function definitions for replacement.\n     */\n    static parenthesize(label) {\n        return FunctionFormatter._process(parse(label, {\n            brackets: ['()']\n        }));\n    }\n\n    /**\n     * Preprocess the parenthesized output so that format object arguments are parameterized\n     */\n    static parenthesizeWithArguments(label) {\n        const parenthesized = FunctionFormatter.parenthesize(label);\n        return parenthesized.map(entry => {\n            if (entry && entry.arguments) {\n                if (entry.arguments.length < 2) {\n                    entry.arguments = FunctionFormatter.getArguments(entry.arguments[0]);\n                } else {\n                    console.log('unexpected arguments, expected a single string:', entry);\n                }\n            }\n            return entry;\n        });\n    }\n\n    /**\n     * Given a label, return the list of potential functions found in it.\n     */\n    static findFunctions(label) {\n        return FunctionFormatter.parenthesizeWithArguments(label).filter(entry => entry && entry.name !== undefined);\n    }\n\n    /**\n     * Given an argument string, return a list of arguments.\n     */\n    static getArguments(args) {\n        const argsString = (args === undefined || args === null)? '' : args;\n        if (argsString.length === 0) {\n            return [];\n        }\n        const split = argsString.split(ARGUMENT_MATCH);\n        return Array.isArray(split) ? split : [split];\n    }\n\n    /**\n     * Given a label, replace instances of the functions in the replacements object.\n     * @param {string} label - the label string\n     * @param {*} replacements - an object of function names and their callbacks\n     */\n    static replace(label, replacements) {\n        const parenthesized = FunctionFormatter.parenthesizeWithArguments(label);\n\n        let ret = '';\n        parenthesized.forEach(token => {\n            if (isString(token)) {\n                // just a regular scalar\n                ret += token;\n            } else if (token.name) {\n                // potential function, check against replacements\n                if (replacements && replacements.hasOwnProperty(token.name)) {\n                    ret += replacements[token.name].apply(replacements[token.name], token.arguments);\n                } else {\n                    // not a matching function, just put it back\n                    ret += token.name + '(';\n                    if (token.arguments) {\n                        ret += token.arguments.join(', ');\n                    }\n                    ret += ')';\n                }\n            } else {\n                console.log('this should not happen... token=', token);\n            }\n        });\n        return ret;\n    }\n\n    /**\n     * Given a label and a set of OpenNMS measurements metadata, replace default\n     * functions like `nodeToLabel` and `resourceToName`.\n     * @param {string} label - the label string\n     * @param {*} replacements - an object of function names and their callbacks\n     */\n    static format(label, metadata) {\n        return FunctionFormatter.replace(label, {\n            nodeToLabel: (nodeCriteria) => {\n                const node = FunctionFormatter._getNodeFromCriteria(metadata, nodeCriteria);\n                if (node) {\n                    return node.label;\n                }\n                return nodeCriteria;\n            },\n            resourceToLabel: (criteriaOrResourceId, partialResourceId) => {\n                const resource = FunctionFormatter._getResource(metadata, criteriaOrResourceId, partialResourceId);\n                if (resource) {\n                    return resource.label;\n                }\n                return partialResourceId ? [criteriaOrResourceId, partialResourceId].join('.') : criteriaOrResourceId;\n            },\n            resourceToName: (criteriaOrResourceId, partialResourceId) => {\n                const resource = FunctionFormatter._getResource(metadata, criteriaOrResourceId, partialResourceId);\n                if (resource) {\n                    return resource.name;\n                }\n                return partialResourceId ? [criteriaOrResourceId, partialResourceId].join('.') : criteriaOrResourceId;\n            },\n            resourceToInterface: (criteriaOrResourceId, partialResourceId) => {\n                const resource = FunctionFormatter._getResource(metadata, criteriaOrResourceId, partialResourceId);\n                if (resource) {\n                    let match = resource.name.match(/^(\\w+)/);\n                    if (!match) {\n                        match = resource.label.match(/^(\\w+)/);\n                    }\n                    if (match) {\n                        return match[1];\n                    }\n                }\n                return partialResourceId ? [criteriaOrResourceId, partialResourceId].join('.') : criteriaOrResourceId;\n            }\n        });\n    }\n\n    /**\n     * Process the raw output of `parenthesis.parse` to detect functions.\n     */\n    static _process(args) {\n        const ret = [];\n        const matcher = /^(.*?)(\\w+?)\\($/;\n        let skip = false;\n        args.forEach((arg, index) => {\n            if (skip) {\n                skip = false;\n                return;\n            }\n            const prev = ret.length ? ret[ret.length - 1] : undefined;\n            const next = args[index + 1];\n\n            let match;\n            if (Array.isArray(arg)) {\n                ret.push(FunctionFormatter._process(arg));\n            } else if ((match = matcher.exec(arg)) !== null) {\n                let prefix = match[1];\n                if (prefix && prefix.length > 0) {\n                    if (prefix.startsWith(')') && prev && prev.name) {\n                        prefix = prefix.replace(/^\\)/, '');\n                    }\n                    ret.push(prefix);\n                }\n                ret.push({\n                    name: match[2],\n                    arguments: FunctionFormatter._process(next)\n                });\n                skip = true;\n            } else if (isString(arg) && arg.startsWith(')') && prev && prev.name) {\n                const replacement = arg.replace(/^\\)/, '');\n                if (replacement.length > 0) {\n                    ret.push(replacement);\n                }\n            } else {\n                ret.push(arg);\n            }\n        });\n        return FunctionFormatter._flatten(ret);\n    }\n\n    /**\n     * Combine string values in processed parenthesized output (from `_process`)\n     * so that we end up with a flat array of scalar strings and function replacements.\n     */\n    static _flatten(args) {\n        let ret = [];\n        args.forEach((arg) => {\n            if (isString(arg)) {\n                if (arg.length === 0) {\n                    return;\n                }\n                const prev = getLast(ret);\n                // argument is a string-part of the parsed label\n                if (isString(prev)) {\n                    ret[ret.length - 1] += arg;\n                } else {\n                    ret.push(arg);\n                }\n            } else if (arg && arg.arguments) {\n                // argument is a function, whose arguments may be flattenable as well\n                arg.arguments = FunctionFormatter._flatten(arg.arguments);\n                ret.push(arg);\n            } else if (Array.isArray(arg)) {\n                // argument is sub-parens that need further flattening\n                const result = FunctionFormatter._flatten(arg);\n                result.forEach((res) => {\n                    const prev = getLast(ret);\n                    if (isString(res)) {\n                        if (res.trim().length === 0) {\n                            return;\n                        }\n                        if (isString(prev)) {\n                            ret[ret.length - 1] += res;\n                        } else {\n                            ret.push(res);\n                        }\n                    } else if (res && res.arguments) {\n                        // argument is a function\n                        ret.push(res);\n                    } else {\n                        throw new Error('cannot reach here');\n                    }\n                });\n            } else {\n                throw new Error('cannot reach here');\n            }\n        });\n        return ret;\n    }\n\n    static _getNodeFromCriteria(metadata, nodeCriteria) {\n        let nodeId, foreignSource, foreignId;\n        if (nodeCriteria && nodeCriteria.indexOf(':') > 0) {\n            [foreignSource, foreignId] = nodeCriteria.split(':');\n        } else {\n            nodeId = parseInt(nodeCriteria, 10);\n        }\n        return FunctionFormatter._getNodeFromMetadata(metadata, nodeId, foreignSource, foreignId);\n    }\n\n    static _getNodeFromMetadata(metadata, nodeId, foreignSource, foreignId) {\n        if (metadata && metadata.nodes) {\n            const ret = metadata.nodes.filter((node) => {\n                return (nodeId !== undefined && node.id === nodeId) ||\n                (foreignSource !== undefined && foreignId !== undefined &&\n                    node['foreign-source'] === foreignSource && node['foreign-id'] === foreignId);\n            })[0];\n            if (ret !== undefined) {\n                return ret;\n            }\n        }\n        //console.warn('Unable to locate node ' + [nodeId, foreignSource, foreignId].join(',') + ' in metadata.', metadata);\n        return null;\n    }\n\n    static _getResource(metadata, criteriaOrResourceId, partialResourceId) {\n        if (partialResourceId === undefined) {\n            for (const resource of metadata.resources) {\n                if (resource.id === criteriaOrResourceId) {\n                    return resource;\n                }\n            }\n        } else {\n            const node = FunctionFormatter._getNodeFromCriteria(metadata, criteriaOrResourceId);\n            if (node) {\n                const resource = FunctionFormatter._getResourceFromCriteria(metadata, partialResourceId, 'node[' + node['foreign-source'] + ':' + node['foreign-id'] + ']', 'node[' + node.id + ']');\n                if (resource) {\n                    return resource;\n                }\n            }\n        }\n        //console.warn('Unable to locate resource ' + [criteriaOrResourceId,partialResourceId].join('.') + ' in metadata.', metadata);\n        return null;\n    }\n\n    static _getResourceFromCriteria(metadata, resourceCriteria, ...nodeCriterias) {\n        if (metadata && metadata.resources) {\n            const ret = metadata.resources.filter((resource) => {\n                if (resource.id === resourceCriteria) return true;\n                for (const criteria of nodeCriterias.map(c => c + '.' + resourceCriteria)) {\n                    if (resource.id === criteria) {\n                        return true;\n                    }\n                }\n                return false;\n            })[0];\n            if (ret !== undefined) {\n                return ret;\n            }\n        }\n        //console.warn('Unable to locate resource ' + resourceCriteria + ' in metadata.', metadata);\n        return null;\n    }\n}"]}