{"version":3,"sources":["../../../src/datasources/flow-ds/flow_functions.js"],"names":["addFuncDef","funcDef","params","defaultParams","category","push","index","name","shortName","FuncInstance","options","def","withDefaultParams","slice","updateText","_","$","categories","Combine","Filter","Transform","type","each","funcList","catName","sortBy","prototype","render","parameters","map","value","paramType","isNumeric","bind","_hasMultipleParamsInString","strValue","indexOf","optional","updateParam","split","partVal","idx","trim","splice","length","text","join","Gfuncs","isString","message","filteredCategories","functions"],"mappings":"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","file":"flow_functions.js","sourcesContent":["import _ from 'lodash';\nimport $ from 'angular';\n\nlet index = [];\nlet categories = {\n  Combine: [],\n  Filter: [],\n  Transform: []\n};\n\nfunction addFuncDef(funcDef) {\n  funcDef.params = funcDef.params || [];\n  funcDef.defaultParams = funcDef.defaultParams || [];\n\n  if (funcDef.category) {\n    funcDef.category.push(funcDef);\n  }\n  index[funcDef.name] = funcDef;\n  index[funcDef.shortName || funcDef.name] = funcDef;\n}\n\n// Combine\n\naddFuncDef({\n  name: 'topN',\n  category: categories.Combine,\n  params: [{name: \"n\", type: \"int\",}],\n  defaultParams: [10]\n});\n\naddFuncDef({\n  name: 'includeOther',\n  category: categories.Combine\n});\n\n// Filter\n\naddFuncDef({\n  name: 'withExporterNode',\n  category: categories.Filter,\n  params: [{name: \"nodeCriteria\", type: \"string\"}]\n});\n\naddFuncDef({\n  name: 'withIfIndex',\n  category: categories.Filter,\n  params: [{name: \"ifIndex\", type: \"int\"}]\n});\n\n// Transform\n\naddFuncDef({\n  name: 'perSecond',\n  category: categories.Transform\n});\n\naddFuncDef({\n  name: 'toBits',\n  category: categories.Transform\n});\n\naddFuncDef({\n  name: 'negativeEgress',\n  category: categories.Transform\n});\n\naddFuncDef({\n  name: 'negativeIngress',\n  category: categories.Transform\n});\n\naddFuncDef({\n  name: 'asTableSummary',\n  category: categories.Transform\n});\n\naddFuncDef({\n  name: 'combineIngressEgress',\n  category: categories.Transform\n});\n\naddFuncDef({\n  name: 'onlyIngress',\n  category: categories.Transform\n});\n\naddFuncDef({\n  name: 'onlyEgress',\n  category: categories.Transform\n});\n\n_.each(categories, function (funcList, catName) {\n  categories[catName] = _.sortBy(funcList, 'name');\n});\n\nfunction FuncInstance(funcDef, options) {\n  this.def = funcDef;\n  this.params = [];\n\n  if (options && options.withDefaultParams) {\n    this.params = funcDef.defaultParams.slice(0);\n  }\n\n  this.updateText();\n}\n\nFuncInstance.prototype.render = function (/* metricExp */) {\n  return {\n    name: this.def.name,\n    parameters: _.map(this.params, function (value, index) {\n      let paramType = this.def.params[index].type;\n      if (paramType === 'int' || paramType === 'value_or_series' || paramType === 'boolean') {\n        return value;\n      }\n      else if (paramType === 'int_or_interval' && $.isNumeric(value)) {\n        return value;\n      }\n      return value;\n    }.bind(this))\n  };\n};\n\nFuncInstance.prototype._hasMultipleParamsInString = function (strValue, index) {\n  if (strValue.indexOf(',') === -1) {\n    return false;\n  }\n\n  return this.def.params[index + 1] && this.def.params[index + 1].optional;\n};\n\nFuncInstance.prototype.updateParam = function (strValue, index) {\n  // handle optional parameters\n  // if string contains ',' and next param is optional, split and update both\n  if (this._hasMultipleParamsInString(strValue, index)) {\n    _.each(strValue.split(','), function (partVal, idx) {\n      this.updateParam(partVal.trim(), index + idx);\n    }.bind(this));\n    return;\n  }\n\n  if (strValue === '' && this.def.params[index].optional) {\n    this.params.splice(index, 1);\n  }\n  else {\n    this.params[index] = strValue;\n  }\n\n  this.updateText();\n};\n\nFuncInstance.prototype.updateText = function () {\n  if (this.params.length === 0) {\n    this.text = this.def.name + '()';\n    return;\n  }\n\n  let text = this.def.name + '(';\n  text += this.params.join(', ');\n  text += ')';\n  this.text = text;\n};\n\nexport class Gfuncs {\n  static createFuncInstance(funcDef, options) {\n    if (_.isString(funcDef)) {\n      if (!index[funcDef]) {\n        throw {message: 'Method not found ' + name};\n      }\n      funcDef = index[funcDef];\n    }\n    return new FuncInstance(funcDef, options);\n  }\n\n  static getFuncDef(name) {\n    return index[name];\n  }\n\n  static getCategories(/* graphiteVersion */) {\n    let filteredCategories = {};\n    _.each(categories, function (functions, category) {\n      if (functions.length) {\n        filteredCategories[category] = functions;\n      }\n    });\n\n    return filteredCategories;\n  }\n}\n"]}