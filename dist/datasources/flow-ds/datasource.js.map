{"version":3,"sources":["../../../src/datasources/flow-ds/datasource.js"],"names":["_","ClientDelegate","FlowDatasource","instanceSettings","$q","backendSrv","templateSrv","type","url","name","q","client","options","start","range","from","valueOf","end","to","step","Math","floor","maxDataPoints","targets","length","Error","target","metric","undefined","when","N","getFunctionParameterOrDefault","includeOther","isFunctionPresent","exporterNode","ifIndex","asTableSummary","getSeriesForTopNConversations","then","data","toSeries","series","getSummaryForTopNConversations","toTable","table","getSeriesForTopNApplications","getSummaryForTopNApplications","getClientWithMetadata","metadata","status","message","title","catch","e","query","resolve","replace","exporterNodesRegex","interfacesOnExporterNodeRegex","exporterNodesQuery","match","metricFindExporterNodes","interfacesOnExporterNodeQuery","metricFindInterfacesOnExporterNode","defaultRangeMs","parseInt","getExporters","results","each","exporters","exporter","push","text","label","value","id","expandable","getExporter","interfaces","iff","index","idx","def","func","getFirstFunction","parameters","columns","map","headers","column","rows","flowSeries","perSecond","negativeEgress","negativeIngress","combineIngressEgress","values","timestamps","i","j","nRows","nCols","datapoints","multiplier","suffix","ingress","sumMatchingTargets","targetsByName","groupBy","s","newSeries","t","K","summedDatapoints","Array","k","targetDatapoints","n","valueToAdd","matchingFunctions","filter","functions","f"],"mappings":"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","file":"datasource.js","sourcesContent":["import _ from 'lodash';\nimport {ClientDelegate} from '../../lib/client_delegate';\n\nexport class FlowDatasource {\n\n  constructor(instanceSettings, $q, backendSrv, templateSrv) {\n    this.type = instanceSettings.type;\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    this.q = $q;\n    this.backendSrv = backendSrv;\n    this.templateSrv = templateSrv;\n    this.client = new ClientDelegate(instanceSettings, backendSrv, $q);\n  }\n\n  query(options) {\n    let start = options.range.from.valueOf();\n    let end = options.range.to.valueOf();\n    let step = Math.floor((end - start) / options.maxDataPoints);\n\n    if (options.targets.length > 1) {\n      throw new Error(\"Multiple targets are not currently supported when using the OpenNMS Flow Datasource.\");\n    }\n\n    // Grab the first target\n    let target = options.targets[0];\n    if (target.metric === undefined || target.metric === null) {\n      // Nothing to query - this can happen when we initially create the panel\n      // and have not yet selected a metric\n      return this.q.when({'data': []});\n    }\n\n    // Combine\n    let N = this.getFunctionParameterOrDefault(target, 'topN', 10);\n    let includeOther = FlowDatasource.isFunctionPresent(target, 'includeOther');\n    // Filter\n    let exporterNode = this.getFunctionParameterOrDefault(target, 'withExporterNode', 0);\n    let ifIndex = this.getFunctionParameterOrDefault(target, 'withIfIndex', 0);\n    // Transform\n    let asTableSummary = FlowDatasource.isFunctionPresent(target, 'asTableSummary');\n\n    if (target.metric === 'conversations') {\n      if (!asTableSummary) {\n        return this.client.getSeriesForTopNConversations(N, start, end, step, exporterNode, ifIndex).then(series => {\n          return {\n            data: FlowDatasource.toSeries(target, series)\n          };\n        });\n      } else {\n        return this.client.getSummaryForTopNConversations(N, start, end, exporterNode, ifIndex).then(table => {\n          return {\n            data: FlowDatasource.toTable(table)\n          };\n        });\n      }\n    } else if (target.metric === 'applications') {\n      if (!asTableSummary) {\n        return this.client.getSeriesForTopNApplications(N, start, end, step, includeOther, exporterNode, ifIndex).then(series => {\n          return {\n            data: FlowDatasource.toSeries(target, series)\n          };\n        });\n      } else {\n        return this.client.getSummaryForTopNApplications(N, start, end, includeOther, exporterNode, ifIndex).then(table => {\n          return {\n            data: FlowDatasource.toTable(table)\n          };\n        });\n      }\n    } else {\n      throw 'Unsupported target metric: ' + target.metric;\n    }\n  }\n\n  testDatasource() {\n    return this.client.getClientWithMetadata()\n      .then(metadata => {\n        if (metadata) {\n          return {\n            status: \"success\",\n            message: \"Data source is working\",\n            title: \"Success\"\n          };\n        } else {\n          return {\n            status: \"danger\",\n            message: \"OpenNMS provided a response, but no metadata was found.\",\n            title: \"Unexpected Response\"\n          }\n        }\n      }).catch(e => {\n        if (e.message === \"Unsupported Version\") {\n          return {\n            status: \"danger\",\n            message: \"The OpenNMS version you are trying to connect to is not supported. \" +\n            \"OpenNMS Horizon version >= 22.0.0 or OpenNMS Meridian version >= 2018.1.0 is required.\",\n            title: e.message\n          }\n        } else {\n          throw e;\n        }\n      });\n  }\n\n  annotationQuery(options) {\n    return this.q.when([]);\n  }\n\n  // Used by template queries\n  metricFindQuery(query) {\n    if (query === null || query === undefined || query === \"\") {\n      return this.$q.resolve([]);\n    }\n    query = this.templateSrv.replace(query);\n\n    let exporterNodesRegex = /exporterNodesWithFlows\\((.*)\\)/;\n    let interfacesOnExporterNodeRegex = /interfacesOnExporterNodeWithFlows\\((.*)\\)/;\n\n    let exporterNodesQuery = query.match(exporterNodesRegex);\n    if (exporterNodesQuery) {\n      return this.metricFindExporterNodes(exporterNodesQuery[1]);\n    }\n\n    let interfacesOnExporterNodeQuery = query.match(interfacesOnExporterNodeRegex);\n    if (interfacesOnExporterNodeQuery) {\n      return this.metricFindInterfacesOnExporterNode(interfacesOnExporterNodeQuery[1]);\n    }\n\n    return this.$q.resolve([]);\n  }\n\n  metricFindExporterNodes(query) {\n    const defaultRangeMs = 14400000;\n    let range = defaultRangeMs;\n    if (query != null && query.length > 0) {\n      range = parseInt(query) || defaultRangeMs;\n    }\n    return this.client.getExporters(-range, 0).then(exporters => {\n      let results = [];\n      _.each(exporters, function (exporter) {\n        results.push({text: exporter.label, value: exporter.id, expandable: true});\n      });\n      return results;\n    });\n  }\n\n  metricFindInterfacesOnExporterNode(query) {\n    return this.client.getExporter(query).then(exporter => {\n      let results = [];\n      _.each(exporter.interfaces, function (iff) {\n        results.push({text: iff.name + \"(\" + iff.index + \")\", value: iff.index, expandable: true});\n      });\n      return results;\n    });\n  }\n\n  static toTable(table) {\n    let columns = _.map(table.headers, column => {\n      return {\"text\": column}\n    });\n\n    return [\n      {\n        \"columns\": columns,\n        \"rows\": table.rows,\n        \"type\": \"table\",\n      }\n    ];\n  }\n\n  static toSeries(target, flowSeries) {\n    let perSecond = FlowDatasource.isFunctionPresent(target, 'perSecond');\n    let negativeEgress = FlowDatasource.isFunctionPresent(target, 'negativeEgress');\n    let negativeIngress = FlowDatasource.isFunctionPresent(target, 'negativeIngress');\n    let combineIngressEgress = FlowDatasource.isFunctionPresent(target, 'combineIngressEgress');\n\n    let start = flowSeries.start.valueOf();\n    let end = flowSeries.end.valueOf();\n    let columns = flowSeries.columns;\n    let values = flowSeries.values;\n    let timestamps = flowSeries.timestamps;\n    let series = [];\n    let i, j, nRows, nCols, datapoints;\n\n    let step = timestamps[1] - timestamps[0];\n\n    if (timestamps !== undefined) {\n      nRows = timestamps.length;\n      nCols = columns.length;\n\n      for (i = 0; i < nCols; i++) {\n        let multiplier = negativeIngress ? -1 : 1;\n        let suffix = \" (In)\";\n        if (!columns[i].ingress) {\n          multiplier = negativeEgress ? -1 : 1;\n          suffix = \" (Out)\";\n        }\n        if (combineIngressEgress) {\n          // Remove any suffix, so that ingress and egress both have the same label\n          suffix = \"\";\n        }\n        if (perSecond) {\n          multiplier /= step / 1000;\n        }\n\n        datapoints = [];\n        for (j = 0; j < nRows; j++) {\n          // Skip rows that are out-of-range\n          if (timestamps[j] < start || timestamps[j] > end) {\n            continue;\n          }\n\n          if (values[i][j] === 'NaN') {\n            values[i][j] = null;\n          }\n\n          datapoints.push([values[i][j] * multiplier, timestamps[j]]);\n        }\n\n        series.push({\n          target: columns[i].label + suffix,\n          datapoints: datapoints\n        });\n      }\n    }\n\n    if (combineIngressEgress) {\n      series = FlowDatasource.sumMatchingTargets(series);\n    }\n\n    return series;\n  }\n\n  static sumMatchingTargets(series) {\n    let targetsByName = _.groupBy(series, (s) => s.target);\n    let newSeries = [];\n    _.each(targetsByName, (t) => {\n      let target = t[0].target;\n      let K = t.length;\n      let N = t[0].datapoints.length;\n      let summedDatapoints = new Array(N);\n      for (let k = 0; k < K; k++) {\n        let targetDatapoints = t[k].datapoints;\n        for (let n = 0; n < N; n++) {\n          if (summedDatapoints[n] == null) {\n            summedDatapoints[n] = [0, targetDatapoints[n][1]];\n          }\n          let valueToAdd = targetDatapoints[n][0] == null ? 0 : targetDatapoints[n][0];\n          summedDatapoints[n][0] = summedDatapoints[n][0] + valueToAdd;\n        }\n      }\n      newSeries.push({\n        target: target,\n        datapoints: summedDatapoints\n      })\n    });\n    return newSeries;\n  }\n\n  static getFirstFunction(target, name) {\n    let matchingFunctions = _.filter(target.functions, function (f) {\n      return f.name === name;\n    });\n    return matchingFunctions.length > 0 ? matchingFunctions[0] : null;\n  }\n\n  static isFunctionPresent(target, name) {\n    return FlowDatasource.getFirstFunction(target, name) !== null;\n  }\n\n  getFunctionParameterOrDefault(target, name, idx, def) {\n    let func = FlowDatasource.getFirstFunction(target, name);\n    if (func === null) {\n      // No match, use the default value\n      return def;\n    }\n    // Return the parameter value, and perform any required template variable substitutions\n    return this.templateSrv.replace(func.parameters[idx]);\n  }\n}\n"]}