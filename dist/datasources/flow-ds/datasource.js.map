{"version":3,"sources":["../../../src/datasources/flow-ds/datasource.js"],"names":["_","ClientDelegate","FlowDatasource","instanceSettings","$q","backendSrv","templateSrv","type","url","name","q","client","options","start","range","from","valueOf","end","to","step","Math","floor","maxDataPoints","targets","length","Error","target","metric","undefined","when","N","getFunctionParameterOrDefault","includeOther","isFunctionPresent","exporterNode","ifIndex","asTableSummary","getSeriesForTopNConversations","then","data","toSeries","series","getSummaryForTopNConversations","toTable","table","getSeriesForTopNApplications","getSummaryForTopNApplications","getClientWithMetadata","metadata","status","message","title","catch","e","query","resolve","replace","exporterNodesRegex","interfacesOnExporterNodeRegex","exporterNodesQuery","match","metricFindExporterNodes","interfacesOnExporterNodeQuery","metricFindInterfacesOnExporterNode","getExporters","results","each","exporters","exporter","push","text","label","value","id","expandable","getExporter","interfaces","iff","index","idx","def","func","getFirstFunction","parameters","columns","headers","map","column","rows","flowSeries","toBits","perSecond","negativeEgress","negativeIngress","combineIngressEgress","onlyIngress","onlyEgress","values","timestamps","i","j","nRows","nCols","datapoints","ingress","multiplier","suffix","sumMatchingTargets","targetsByName","groupBy","s","newSeries","t","K","summedDatapoints","Array","k","targetDatapoints","n","valueToAdd","matchingFunctions","filter","functions","f"],"mappings":"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","file":"datasource.js","sourcesContent":["import _ from 'lodash';\nimport {ClientDelegate} from '../../lib/client_delegate';\n\nexport class FlowDatasource {\n\n  constructor(instanceSettings, $q, backendSrv, templateSrv) {\n    this.type = instanceSettings.type;\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    this.q = $q;\n    this.backendSrv = backendSrv;\n    this.templateSrv = templateSrv;\n    this.client = new ClientDelegate(instanceSettings, backendSrv, $q);\n  }\n\n  query(options) {\n    let start = options.range.from.valueOf();\n    let end = options.range.to.valueOf();\n    let step = Math.floor((end - start) / options.maxDataPoints);\n\n    if (options.targets.length > 1) {\n      throw new Error(\"Multiple targets are not currently supported when using the OpenNMS Flow Datasource.\");\n    }\n\n    // Grab the first target\n    let target = options.targets[0];\n    if (target.metric === undefined || target.metric === null) {\n      // Nothing to query - this can happen when we initially create the panel\n      // and have not yet selected a metric\n      return this.q.when({'data': []});\n    }\n\n    // Combine\n    let N = this.getFunctionParameterOrDefault(target, 'topN', 0, 10);\n    let includeOther = FlowDatasource.isFunctionPresent(target, 'includeOther');\n    // Filter\n    let exporterNode = this.getFunctionParameterOrDefault(target, 'withExporterNode', 0);\n    let ifIndex = this.getFunctionParameterOrDefault(target, 'withIfIndex', 0);\n    // Transform\n    let asTableSummary = FlowDatasource.isFunctionPresent(target, 'asTableSummary');\n\n    if (target.metric === 'conversations') {\n      if (!asTableSummary) {\n        return this.client.getSeriesForTopNConversations(N, start, end, step, exporterNode, ifIndex).then(series => {\n          return {\n            data: FlowDatasource.toSeries(target, series)\n          };\n        });\n      } else {\n        return this.client.getSummaryForTopNConversations(N, start, end, exporterNode, ifIndex).then(table => {\n          return {\n            data: FlowDatasource.toTable(table)\n          };\n        });\n      }\n    } else if (target.metric === 'applications') {\n      if (!asTableSummary) {\n        return this.client.getSeriesForTopNApplications(N, start, end, step, includeOther, exporterNode, ifIndex).then(series => {\n          return {\n            data: FlowDatasource.toSeries(target, series)\n          };\n        });\n      } else {\n        return this.client.getSummaryForTopNApplications(N, start, end, includeOther, exporterNode, ifIndex).then(table => {\n          return {\n            data: FlowDatasource.toTable(table)\n          };\n        });\n      }\n    } else {\n      throw 'Unsupported target metric: ' + target.metric;\n    }\n  }\n\n  testDatasource() {\n    return this.client.getClientWithMetadata()\n      .then(metadata => {\n        if (metadata) {\n          return {\n            status: \"success\",\n            message: \"Data source is working\",\n            title: \"Success\"\n          };\n        } else {\n          return {\n            status: \"danger\",\n            message: \"OpenNMS provided a response, but no metadata was found.\",\n            title: \"Unexpected Response\"\n          }\n        }\n      }).catch(e => {\n        if (e.message === \"Unsupported Version\") {\n          return {\n            status: \"danger\",\n            message: \"The OpenNMS version you are trying to connect to is not supported. \" +\n            \"OpenNMS Horizon version >= 22.0.0 or OpenNMS Meridian version >= 2018.1.0 is required.\",\n            title: e.message\n          }\n        } else {\n          throw e;\n        }\n      });\n  }\n\n  annotationQuery(/* options */) {\n    return this.q.when([]);\n  }\n\n  // Used by template queries\n  metricFindQuery(query) {\n    if (query === null || query === undefined || query === \"\") {\n      return this.$q.resolve([]);\n    }\n    query = this.templateSrv.replace(query);\n\n    let exporterNodesRegex = /exporterNodesWithFlows\\((.*)\\)/;\n    let interfacesOnExporterNodeRegex = /interfacesOnExporterNodeWithFlows\\((.*)\\)/;\n\n    let exporterNodesQuery = query.match(exporterNodesRegex);\n    if (exporterNodesQuery) {\n      return this.metricFindExporterNodes(exporterNodesQuery[1]);\n    }\n\n    let interfacesOnExporterNodeQuery = query.match(interfacesOnExporterNodeRegex);\n    if (interfacesOnExporterNodeQuery) {\n      return this.metricFindInterfacesOnExporterNode(interfacesOnExporterNodeQuery[1]);\n    }\n\n    return this.$q.resolve([]);\n  }\n\n  metricFindExporterNodes(/* query */) {\n    return this.client.getExporters().then(exporters => {\n      let results = [];\n      _.each(exporters, function (exporter) {\n        results.push({text: exporter.label, value: exporter.id, expandable: true});\n      });\n      return results;\n    });\n  }\n\n  metricFindInterfacesOnExporterNode(query) {\n    return this.client.getExporter(query).then(exporter => {\n      let results = [];\n      _.each(exporter.interfaces, function (iff) {\n        results.push({text: iff.name + \"(\" + iff.index + \")\", value: iff.index, expandable: true});\n      });\n      return results;\n    });\n  }\n\n  static toTable(table) {\n    let columns = table && table.headers ? _.map(table.headers, column => {\n      return {\"text\": column}\n    }) : [];\n\n    return [\n      {\n        \"columns\": columns,\n        \"rows\": table.rows,\n        \"type\": \"table\",\n      }\n    ];\n  }\n\n  static toSeries(target, flowSeries) {\n    let toBits = FlowDatasource.isFunctionPresent(target, 'toBits');\n    let perSecond = FlowDatasource.isFunctionPresent(target, 'perSecond');\n    let negativeEgress = FlowDatasource.isFunctionPresent(target, 'negativeEgress');\n    let negativeIngress = FlowDatasource.isFunctionPresent(target, 'negativeIngress');\n    let combineIngressEgress = FlowDatasource.isFunctionPresent(target, 'combineIngressEgress');\n    let onlyIngress = FlowDatasource.isFunctionPresent(target, 'onlyIngress');\n    let onlyEgress = FlowDatasource.isFunctionPresent(target, 'onlyEgress');\n\n    let start = flowSeries.start.valueOf();\n    let end = flowSeries.end.valueOf();\n    let columns = flowSeries.columns;\n    let values = flowSeries.values;\n    let timestamps = flowSeries.timestamps;\n    let series = [];\n    let i, j, nRows, nCols, datapoints;\n\n    let step = timestamps[1] - timestamps[0];\n\n    if (timestamps !== undefined) {\n      nRows = timestamps.length;\n      nCols = columns.length;\n\n      for (i = 0; i < nCols; i++) {\n        // Optionally skip egress or ingress columns\n        if (onlyIngress && !columns[i].ingress) {\n          continue;\n        }\n        if (onlyEgress && columns[i].ingress) {\n          continue;\n        }\n\n        let multiplier = negativeIngress ? -1 : 1;\n        let suffix = \" (In)\";\n        if (!columns[i].ingress) {\n          multiplier = negativeEgress ? -1 : 1;\n          suffix = \" (Out)\";\n        }\n        if (combineIngressEgress) {\n          // Remove any suffix, so that ingress and egress both have the same label\n          suffix = \"\";\n        }\n        if (perSecond) {\n          multiplier /= step / 1000;\n        }\n        if (toBits) {\n          // Convert from bytes to bits\n          multiplier *= 8;\n        }\n\n        datapoints = [];\n        for (j = 0; j < nRows; j++) {\n          // Skip rows that are out-of-range\n          if (timestamps[j] < start || timestamps[j] > end) {\n            continue;\n          }\n\n          if (values[i][j] === 'NaN') {\n            values[i][j] = null;\n          }\n\n          datapoints.push([values[i][j] * multiplier, timestamps[j]]);\n        }\n\n        series.push({\n          target: columns[i].label + suffix,\n          datapoints: datapoints\n        });\n      }\n    }\n\n    if (combineIngressEgress) {\n      series = FlowDatasource.sumMatchingTargets(series);\n    }\n\n    return series;\n  }\n\n  static sumMatchingTargets(series) {\n    let targetsByName = _.groupBy(series, (s) => s.target);\n    let newSeries = [];\n    _.each(targetsByName, (t) => {\n      let target = t[0].target;\n      let K = t.length;\n      let N = t[0].datapoints.length;\n      let summedDatapoints = new Array(N);\n      for (let k = 0; k < K; k++) {\n        let targetDatapoints = t[k].datapoints;\n        for (let n = 0; n < N; n++) {\n          if (summedDatapoints[n] == null) {\n            summedDatapoints[n] = [0, targetDatapoints[n][1]];\n          }\n          let valueToAdd = targetDatapoints[n][0] == null ? 0 : targetDatapoints[n][0];\n          summedDatapoints[n][0] = summedDatapoints[n][0] + valueToAdd;\n        }\n      }\n      newSeries.push({\n        target: target,\n        datapoints: summedDatapoints\n      })\n    });\n    return newSeries;\n  }\n\n  static getFirstFunction(target, name) {\n    let matchingFunctions = _.filter(target.functions, function (f) {\n      return f.name === name;\n    });\n    return matchingFunctions.length > 0 ? matchingFunctions[0] : null;\n  }\n\n  static isFunctionPresent(target, name) {\n    return FlowDatasource.getFirstFunction(target, name) !== null;\n  }\n\n  getFunctionParameterOrDefault(target, name, idx, def) {\n    let func = FlowDatasource.getFirstFunction(target, name);\n    if (func === null) {\n      // No match, use the default value\n      return def;\n    }\n    // Return the parameter value, and perform any required template variable substitutions\n    return this.templateSrv.replace(func.parameters[idx]);\n  }\n}\n"]}