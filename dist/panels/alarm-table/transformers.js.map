{"version":3,"sources":["../../../src/panels/alarm-table/transformers.js"],"names":["transformDataToTable","data","panel","model","TableModel","length","transformer","transformers","transform","message","_","table","description","getColumns","columns","forEach","push","shift","filter","v","every","a","indexOf","transformTable","columnsToInclude","cellsByColumnIndex","each","rows","i","row","emptyColumn","Array","cellsByPanelColumnIndex","j","colDef","idx","findIndex","col","text","k","l","meta","undefined","mergeTables","tables","concat","uniqBy","alarm","JSON","stringify","source","alarmId","id","transformedTables","dat","type","mergedTables"],"mappings":"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","file":"transformers.js","sourcesContent":["import _ from 'lodash';\nimport {TableModel} from './table_model';\n\nlet transformers = {};\n\ntransformers.table = {\n  description: 'Table',\n  getColumns: function(data) {\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    // Create a list containing the column names from each table\n    let columns = [];\n    _.forEach(data, (table) => {\n      columns.push(table.columns);\n    });\n    // Return the intersection of all column names only returning\n    // those that are present in each table\n    // NOTE: _.intersection([array]) should work here, but appears to be broken\n    return columns.shift().filter(function(v) {\n      return columns.every(function(a) {\n        return a.indexOf(v) !== -1;\n      });\n    });\n  },\n\n  transformTable: function(data, columnsToInclude) {\n    let model = new TableModel();\n\n    // Convert the rows to columns\n    let cellsByColumnIndex = [];\n    _.each(data.columns, () => cellsByColumnIndex.push([]));\n\n    // For every row\n    _.each(data.rows, row => {\n      // And every cell in the row\n      for (let i = 0; i < row.length; i++) {\n        // Append the cell to the appropriate column list\n        cellsByColumnIndex[i].push(row[i]);\n      }\n    });\n\n    // Used when no matching column is found\n    let emptyColumn = new Array(data.rows.length);\n\n    // Now reorder the columns according the list of columns in the panel definition\n    let cellsByPanelColumnIndex = [];\n    for (let j = 0; j < columnsToInclude.length; j++) {\n      let colDef = columnsToInclude[j];\n      // Determine the column's index in the given data\n      let idx = _.findIndex(data.columns, col => {\n        return col === colDef.text || col.text === colDef.text;\n      });\n      if (idx < 0) {\n        // The column does not exist\n        cellsByPanelColumnIndex[j] = emptyColumn;\n        continue;\n      }\n      // Re-order\n      cellsByPanelColumnIndex[j] = cellsByColumnIndex[idx];\n    }\n\n    // Convert the columns back to rows\n    model.columns = columnsToInclude;\n    model.rows = [];\n    for (let k = 0; k < cellsByPanelColumnIndex[0].length; k++) {\n      let row = [];\n      for (let l = 0; l < columnsToInclude.length; l++) {\n        row.push(cellsByPanelColumnIndex[l][k]);\n      }\n      // Preserve the meta-data, if any\n      if (data.rows[k].meta !== undefined) {\n        row.meta = data.rows[k].meta;\n      }\n      model.rows.push(row);\n    }\n    return model;\n  },\n\n  mergeTables: function(tables) {\n    let model = new TableModel();\n    // Use the list of columns from the first table:\n    //  transformTable() will ensure that all tables have the same columns\n    model.columns = tables[0].columns;\n    // Concatenate the rows\n    _.each(tables, table => {\n      model.rows = _.concat(model.rows, table.rows);\n    });\n    // De-duplicate by (source, alarm.id) tuple\n    model.rows = _.uniqBy(model.rows, row => {\n      if (row.meta && row.meta.alarm) {\n        return JSON.stringify({\n          source: row.meta.source,\n          alarmId: row.meta.alarm.id\n        });\n      } else {\n        return row;\n      }\n    });\n    return model;\n  },\n\n  transform: function(data, panel, model) {\n    if (!data || data.length === 0) {\n      return;\n    }\n\n    // Determine the list of columns to include\n    let columnsToInclude = [];\n    if (panel.columns && panel.columns.length > 0) {\n      // One or more columns were specified in the column definition, use these\n      columnsToInclude = panel.columns;\n    } else {\n      // Use all the available columns\n      columnsToInclude = this.getColumns(data);\n    }\n\n    // Transform each of the datasource results individually\n    let transformedTables = [];\n    _.each(data, (dat) => {\n      if (dat.type !== 'table') {\n        throw {message: 'Query result is not in table format, try using another transform.'};\n      }\n      transformedTables.push(this.transformTable(dat, columnsToInclude));\n    });\n\n    // Merge the results and update the model\n    let mergedTables = this.mergeTables(transformedTables);\n    model.columns = mergedTables.columns;\n    model.rows = mergedTables.rows;\n  }\n};\n\nfunction transformDataToTable(data, panel) {\n  let model = new TableModel();\n\n  if (!data || data.length === 0) {\n    return model;\n  }\n\n  let transformer = transformers[panel.transform];\n  if (!transformer) {\n    throw {message: 'Transformer ' + panel.transform + ' not found'};\n  }\n\n  transformer.transform(data, panel, model);\n  return model;\n}\n\nexport {transformers, transformDataToTable};\n"]}