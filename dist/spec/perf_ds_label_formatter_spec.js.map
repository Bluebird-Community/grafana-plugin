{"version":3,"sources":["../../src/spec/perf_ds_label_formatter_spec.js"],"names":["FunctionFormatter","FUNCS","exclamationer","arg","insulter","person","insult","describe","it","parsed","parenthesize","expect","to","exist","length","equal","deep","name","arguments","found","findFunctions","res","replace","simpleFunction","metadata","format"],"mappings":"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","file":"perf_ds_label_formatter_spec.js","sourcesContent":["import {FunctionFormatter} from \"../datasources/perf-ds/function_formatter\";\n\nconst FUNCS = {\n    exclamationer: (arg) => {\n        return arg + '!!!';\n    },\n    insulter: (person, insult) => {\n        return person + ' is a total ' + insult + '!';\n    }\n};\n\ndescribe('OpenNMSPMDatasource :: LabelFormatter', () => {\n    describe('parenthesize', () => {\n        it('no parentheses', () => {\n            const parsed = FunctionFormatter.parenthesize('this is just a string');\n            expect(parsed).to.exist;\n            expect(parsed.length).to.equal(1);\n            expect(parsed).to.deep.equal([\n                'this is just a string'\n            ]);\n        });\n        it('simple()', () => {\n            const parsed = FunctionFormatter.parenthesize('simple()');\n            expect(parsed).to.exist;\n            expect(parsed.length).to.equal(1);\n            expect(parsed).to.deep.equal([\n                {\n                    name: 'simple',\n                    arguments: []\n                }\n            ]);\n        });\n        it('nestedParens((foo) or (bar))', () => {\n            const parsed = FunctionFormatter.parenthesize('nestedParens((foo) or (bar))');\n            expect(parsed).to.exist;\n            expect(parsed.length).to.equal(1);\n            expect(parsed).to.deep.equal([\n                {\n                    name: 'nestedParens',\n                    arguments: ['(foo) or (bar)']\n                }\n            ]);\n        });\n        it('prefix nestedParens((yah)) and anotherNested((foo) or (bar)) or something', () => {\n            const parsed = FunctionFormatter.parenthesize('prefix nestedParens((yah)) and anotherNested((foo) or (bar), baz) or something');\n            expect(parsed).to.exist;\n            expect(parsed.length).to.equal(5);\n            expect(parsed).to.deep.equal([\n                'prefix ',\n                {\n                    name: 'nestedParens',\n                    arguments: ['(yah)']\n                },\n                ' and ',\n                {\n                    name: 'anotherNested',\n                    arguments: ['(foo) or (bar), baz']\n                },\n                ' or something'\n            ]);\n        });\n        /*\n        it('outerFunction(nestedFunction(withArgs))', () => {\n            const parsed = FunctionFormatter.parenthesize('outerFunction(nestedFunction(withArgs))');\n            expect(parsed).to.exist;\n            expect(parsed.length).to.equal(1);\n            expect(parsed).to.deep.equal([\n                {\n                    name: 'outerFunction',\n                    arguments: [{\n                        name: 'nestedFunction',\n                        arguments: ['withArgs']\n                    }]\n                }\n            ]);\n        });\n        it('outerFunction(nestedFunction(withArgs), (foo) (bar))', () => {\n            const parsed = FunctionFormatter.parenthesize('outerFunction(nestedFunction(withArgs), (foo) (bar))', true);\n            expect(parsed).to.exist;\n            expect(parsed.length).to.equal(1);\n            expect(parsed).to.deep.equal([\n                {\n                    name: 'outerFunction',\n                    arguments: [\n                        {\n                            name: 'nestedFunction',\n                            arguments: ['withArgs']\n                        },\n                        '(foo) (bar)'\n                    ]\n                }\n            ]);\n        });\n        */\n    });\n\n    describe('findFunctions()', () => {\n        it('find a simple function with no arguments', () => {\n            const found = FunctionFormatter.findFunctions('simpleFunction()');\n            expect(found).to.exist;\n            expect(found.length).to.equal(1);\n            expect(found).to.deep.equal([\n                {\n                    name: 'simpleFunction',\n                    arguments: []\n                }\n            ]);\n        });\n        it('find a simple function with one argument', () => {\n            const found = FunctionFormatter.findFunctions('simpleFunction(foo)');\n            expect(found).to.exist;\n            expect(found.length).to.equal(1);\n            expect(found).to.deep.equal([\n                {\n                    name: 'simpleFunction',\n                    arguments: ['foo']\n                }\n            ]);\n        });\n        it('find a simple function with many arguments', () => {\n            const found = FunctionFormatter.findFunctions('simpleFunction(foo, bar, baz)');\n            expect(found).to.exist;\n            expect(found.length).to.equal(1);\n            expect(found).to.deep.equal([\n                {\n                    name: 'simpleFunction',\n                    arguments: ['foo', 'bar', 'baz']\n                }\n            ]);\n        });\n        it('find multiple functions with arguments', () => {\n            const found = FunctionFormatter.findFunctions('simpleFunction(foo, bar, baz), anotherThing($nodes)');\n            expect(found).to.exist;\n            expect(found.length).to.equal(2);\n            expect(found).to.deep.equal([\n                {\n                    name: 'simpleFunction',\n                    arguments: ['foo', 'bar', 'baz']\n                },\n                {\n                    name: 'anotherThing',\n                    arguments: ['$nodes']\n                }\n            ]);\n        });\n        it('find multiple functions with parens inside them', () => {\n            const found = FunctionFormatter.findFunctions('foo((bar) or (baz), uh-huh) yo(something)');\n            expect(found).to.exist;\n            expect(found.length).to.equal(2);\n            expect(found).to.deep.equal([\n                {\n                    name: 'foo',\n                    arguments: ['(bar) or (baz)', 'uh-huh'],\n                },\n                {\n                    name: 'yo',\n                    arguments: ['something'],\n                },\n            ]);\n        });\n        it('HELM-131', () => {\n            const found = FunctionFormatter.findFunctions('nodeFilter((nodeLabel like ‘This%’) or (nodeLabel like ‘Down%’))');\n            expect(found).to.exist;\n            expect(found.length).to.equal(1);\n            expect(found).to.deep.equal([\n                {\n                    name: 'nodeFilter',\n                    arguments: ['(nodeLabel like ‘This%’) or (nodeLabel like ‘Down%’)'],\n                },\n            ]);\n        });\n        /*\n        it('find multiple recursive functions with arguments', () => {\n            const found = FunctionFormatter.findFunctions('complexFunction(simpleFunction(foo), bar, baz), anotherThing(extraThing(recursiveThing($nodes)))');\n            expect(found).to.exist;\n            expect(found.length).to.equal(5);\n            expect(found).to.deep.equal([\n                {\n                    name: 'simpleFunction',\n                    arguments: ['foo']\n                },\n                {\n                    name: 'complexFunction',\n                    arguments: ['simpleFunction(foo)', 'bar', 'baz']\n                },\n                {\n                    name: 'recursiveThing',\n                    arguments: ['$nodes']\n                },\n                {\n                    name: 'extraThing',\n                    arguments: ['recursiveThing($nodes)']\n                },\n                {\n                    name: 'anotherThing',\n                    arguments: ['extraThing(recursiveThing($nodes))']\n                }\n            ]);\n        });\n        */\n    });\n\n    describe('replace()', () => {\n        it('do not replace an unmatched function', () => {\n            const res = FunctionFormatter.replace('unmatchedFunction()', {\n                simpleFunction: () => {\n                    return 'foo';\n                }\n            });\n            expect(res).to.equal('unmatchedFunction()');\n        });\n        it('replace a simple function without arguments', () => {\n            const res = FunctionFormatter.replace('simpleFunction()', {\n                simpleFunction: () => {\n                    return 'foo';\n                }\n            });\n            expect(res).to.equal('foo');\n        });\n        it('replace a simple function with an argument', () => {\n            const res = FunctionFormatter.replace('exclamationer(foo)', FUNCS);\n            expect(res).to.equal('foo!!!');\n        });\n        it('replace a simple function with multiple arguments', () => {\n            const res = FunctionFormatter.replace('insulter(Bob, jerk)', FUNCS);\n            expect(res).to.equal('Bob is a total jerk!');\n        });\n        it('replace multiple functions', () => {\n            const res = FunctionFormatter.replace('exclamationer(Hey)  insulter(Bob, jerk)', FUNCS);\n            expect(res).to.equal('Hey!!!  Bob is a total jerk!');\n        });\n        /*\n        it('handles nested parentheses', () => {\n            const res = FunctionFormatter.replace('exclamationer((foo) or (bar))  insulter((baz) (monkey(shoe)) (this is raw parentheses), jerk)', FUNCS, true);\n            expect(res).to.equal('(foo) or (bar)!!!  (baz) (monkey(shoe)) (this is raw parentheses) is a total jerk!');\n        });\n        */\n    });\n\n    const metadata = {\n        \"resources\": [\n            {\n                \"id\": \"node[situation-test:nodea].responseTime[127.0.0.1]\",\n                \"label\": \"127.0.0.1\",\n                \"name\": \"localhost\",\n                \"parent-id\": \"node[situation-test:nodea]\",\n                \"node-id\": 1\n            },\n            {\n                \"id\": \"node[situation-test:nodeb].responseTime[127.0.0.1]\",\n                \"label\": \"127.0.0.1\",\n                \"name\": \"localhost\",\n                \"parent-id\": \"node[situation-test:nodeb]\",\n                \"node-id\": 2\n            },\n            {\n                \"id\": \"node[situation-test:nodeb].interfaceSnmp[en0-000123456789]\",\n                \"label\": \"en0 (127.0.0.1, 304.2 Mbps)\",\n                \"name\": \"en0-000123456789\",\n                \"parent-id\": \"node[situation-test:nodeb]\",\n                \"node-id\": 2\n            }\n        ],\n        \"nodes\": [\n            {\n                \"id\": 1,\n                \"label\": \"ThisIsAVeryLongNodeLabel1\",\n                \"foreign-source\": \"situation-test\",\n                \"foreign-id\": \"nodea\"\n            },\n            {\n                \"id\": 2,\n                \"label\": \"ThisIsAVeryLongNodeLabel2\",\n                \"foreign-source\": \"situation-test\",\n                \"foreign-id\": \"nodeb\"\n            }\n        ]\n    };\n\n    describe('format()', () => {\n        it('nodeToLabel(foreignSource:foreignId)', () => {\n            const res = FunctionFormatter.format('nodeToLabel(situation-test:nodea)', metadata);\n            expect(res).to.equal('ThisIsAVeryLongNodeLabel1');\n        });\n        it('nodeToLabel(nodeId)', () => {\n            const res = FunctionFormatter.format('nodeToLabel(1)', metadata);\n            expect(res).to.equal('ThisIsAVeryLongNodeLabel1');\n        });\n        it('nodeToLabel(invalid)', () => {\n            const res = FunctionFormatter.format('nodeToLabel(3)', metadata);\n            expect(res).to.equal('3');\n        });\n\n        it('resourceToLabel(resourceId)', () => {\n            const res = FunctionFormatter.format('resourceToLabel(node[situation-test:nodea].responseTime[127.0.0.1])', metadata);\n            expect(res).to.equal('127.0.0.1');\n        });\n        it('resourceToLabel(situation-test:nodea, responseTime[127.0.0.1])', () => {\n            const res = FunctionFormatter.format('resourceToLabel(situation-test:nodea, responseTime[127.0.0.1])', metadata);\n            expect(res).to.equal('127.0.0.1');\n        });\n        it('resourceToLabel(invalid)', () => {\n            const res = FunctionFormatter.format('resourceToLabel(foo)', metadata);\n            expect(res).to.equal('foo');\n        });\n        it('resourceToLabel(invalid, invalid)', () => {\n            const res = FunctionFormatter.format('resourceToLabel(foo, bar)', metadata);\n            expect(res).to.equal('foo.bar');\n        });\n\n        it('resourceToName(resourceId)', () => {\n            const res = FunctionFormatter.format('resourceToName(node[situation-test:nodea].responseTime[127.0.0.1])', metadata);\n            expect(res).to.equal('localhost');\n        });\n        it('resourceToName(situation-test:nodea, responseTime[127.0.0.1])', () => {\n            const res = FunctionFormatter.format('resourceToName(situation-test:nodea, responseTime[127.0.0.1])', metadata);\n            expect(res).to.equal('localhost');\n        });\n        it('resourceToName(invalid)', () => {\n            const res = FunctionFormatter.format('resourceToName(foo)', metadata);\n            expect(res).to.equal('foo');\n        });\n        it('resourceToName(invalid, invalid)', () => {\n            const res = FunctionFormatter.format('resourceToName(foo, bar)', metadata);\n            expect(res).to.equal('foo.bar');\n        });\n\n        it('resourceToInterface(resourceId)', () => {\n            const res = FunctionFormatter.format('resourceToInterface(node[situation-test:nodeb].interfaceSnmp[en0-000123456789])', metadata);\n            expect(res).to.equal('en0');\n        });\n        it('resourceToInterface(situation-test:nodeb, interfaceSnmp[en0-000123456789])', () => {\n            const res = FunctionFormatter.format('resourceToInterface(situation-test:nodeb, interfaceSnmp[en0-000123456789])', metadata);\n            expect(res).to.equal('en0');\n        });\n        it('resourceToInterface(invalid)', () => {\n            const res = FunctionFormatter.format('resourceToInterface(foo)', metadata);\n            expect(res).to.equal('foo');\n        });\n        it('resourceToInterface(invalid, invalid)', () => {\n            const res = FunctionFormatter.format('resourceToInterface(foo, bar)', metadata);\n            expect(res).to.equal('foo.bar');\n        });\n    });\n});\n"]}