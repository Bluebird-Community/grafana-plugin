{"version":3,"sources":["../../../../src/panels/alarm-table/transformers.js"],"names":["transformers","table","description","getColumns","data","length","columns","forEach","push","shift","filter","v","every","a","indexOf","transformTable","columnsToInclude","model","cellsByColumnIndex","each","rows","i","row","emptyColumn","Array","cellsByPanelColumnIndex","j","colDef","idx","findIndex","col","text","k","l","meta","undefined","mergeTables","tables","concat","uniqBy","alarm","JSON","stringify","source","alarmId","id","transform","panel","transformedTables","dat","type","message","mergedTables","transformDataToTable","transformer"],"mappings":";;;;;;;AAAA;;;;AACA;;;;AAEA,IAAIA,eAAe,EAAnB;;AAEAA,aAAaC,KAAb,GAAqB;AACnBC,eAAa,OADM;AAEnBC,cAAY,oBAASC,IAAT,EAAe;AACzB,QAAI,CAACA,IAAD,IAASA,KAAKC,MAAL,KAAgB,CAA7B,EAAgC;AAC9B,aAAO,EAAP;AACD;;AAED;AACA,QAAIC,UAAU,EAAd;AACA,qBAAEC,OAAF,CAAUH,IAAV,EAAgB,UAACH,KAAD,EAAW;AACzBK,cAAQE,IAAR,CAAaP,MAAMK,OAAnB;AACD,KAFD;AAGA;AACA;AACA;AACA,WAAOA,QAAQG,KAAR,GAAgBC,MAAhB,CAAuB,UAASC,CAAT,EAAY;AACxC,aAAOL,QAAQM,KAAR,CAAc,UAASC,CAAT,EAAY;AAC/B,eAAOA,EAAEC,OAAF,CAAUH,CAAV,MAAiB,CAAC,CAAzB;AACD,OAFM,CAAP;AAGD,KAJM,CAAP;AAKD,GApBkB;;AAsBnBI,kBAAgB,wBAASX,IAAT,EAAeY,gBAAf,EAAiC;AAC/C,QAAIC,QAAQ,6BAAZ;;AAEA;AACA,QAAIC,qBAAqB,EAAzB;AACA,qBAAEC,IAAF,CAAOf,KAAKE,OAAZ,EAAqB;AAAA,aAAMY,mBAAmBV,IAAnB,CAAwB,EAAxB,CAAN;AAAA,KAArB;;AAEA;AACA,qBAAEW,IAAF,CAAOf,KAAKgB,IAAZ,EAAkB,eAAO;AACvB;AACA,WAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIC,IAAIjB,MAAxB,EAAgCgB,GAAhC,EAAqC;AACnC;AACAH,2BAAmBG,CAAnB,EAAsBb,IAAtB,CAA2Bc,IAAID,CAAJ,CAA3B;AACD;AACF,KAND;;AAQA;AACA,QAAIE,cAAc,IAAIC,KAAJ,CAAUpB,KAAKgB,IAAL,CAAUf,MAApB,CAAlB;;AAEA;AACA,QAAIoB,0BAA0B,EAA9B;;AApB+C,+BAqBtCC,CArBsC;AAsB7C,UAAIC,SAASX,iBAAiBU,CAAjB,CAAb;AACA;AACA,UAAIE,MAAM,iBAAEC,SAAF,CAAYzB,KAAKE,OAAjB,EAA0B,eAAO;AACzC,eAAOwB,QAAQH,OAAOI,IAAf,IAAuBD,IAAIC,IAAJ,KAAaJ,OAAOI,IAAlD;AACD,OAFS,CAAV;AAGA,UAAIH,MAAM,CAAV,EAAa;AACX;AACAH,gCAAwBC,CAAxB,IAA6BH,WAA7B;AACA;AACD;AACD;AACAE,8BAAwBC,CAAxB,IAA6BR,mBAAmBU,GAAnB,CAA7B;AAjC6C;;AAqB/C,SAAK,IAAIF,IAAI,CAAb,EAAgBA,IAAIV,iBAAiBX,MAArC,EAA6CqB,GAA7C,EAAkD;AAAA,uBAAzCA,CAAyC;;AAAA,+BAS9C;AAIH;;AAED;AACAT,UAAMX,OAAN,GAAgBU,gBAAhB;AACAC,UAAMG,IAAN,GAAa,EAAb;AACA,SAAK,IAAIY,IAAI,CAAb,EAAgBA,IAAIP,wBAAwB,CAAxB,EAA2BpB,MAA/C,EAAuD2B,GAAvD,EAA4D;AAC1D,UAAIV,MAAM,EAAV;AACA,WAAK,IAAIW,IAAI,CAAb,EAAgBA,IAAIjB,iBAAiBX,MAArC,EAA6C4B,GAA7C,EAAkD;AAChDX,YAAId,IAAJ,CAASiB,wBAAwBQ,CAAxB,EAA2BD,CAA3B,CAAT;AACD;AACD;AACA,UAAI5B,KAAKgB,IAAL,CAAUY,CAAV,EAAaE,IAAb,KAAsBC,SAA1B,EAAqC;AACnCb,YAAIY,IAAJ,GAAW9B,KAAKgB,IAAL,CAAUY,CAAV,EAAaE,IAAxB;AACD;AACDjB,YAAMG,IAAN,CAAWZ,IAAX,CAAgBc,GAAhB;AACD;AACD,WAAOL,KAAP;AACD,GAzEkB;;AA2EnBmB,eAAa,qBAASC,MAAT,EAAiB;AAC5B,QAAIpB,QAAQ,6BAAZ;AACA;AACA;AACAA,UAAMX,OAAN,GAAgB+B,OAAO,CAAP,EAAU/B,OAA1B;AACA;AACA,qBAAEa,IAAF,CAAOkB,MAAP,EAAe,iBAAS;AACtBpB,YAAMG,IAAN,GAAa,iBAAEkB,MAAF,CAASrB,MAAMG,IAAf,EAAqBnB,MAAMmB,IAA3B,CAAb;AACD,KAFD;AAGA;AACAH,UAAMG,IAAN,GAAa,iBAAEmB,MAAF,CAAStB,MAAMG,IAAf,EAAqB,eAAO;AACvC,UAAIE,IAAIY,IAAJ,IAAYZ,IAAIY,IAAJ,CAASM,KAAzB,EAAgC;AAC9B,eAAOC,KAAKC,SAAL,CAAe;AACpBC,kBAAQrB,IAAIY,IAAJ,CAASS,MADG;AAEpBC,mBAAStB,IAAIY,IAAJ,CAASM,KAAT,CAAeK;AAFJ,SAAf,CAAP;AAID,OALD,MAKO;AACL,eAAOvB,GAAP;AACD;AACF,KATY,CAAb;AAUA,WAAOL,KAAP;AACD,GAhGkB;;AAkGnB6B,aAAW,mBAAS1C,IAAT,EAAe2C,KAAf,EAAsB9B,KAAtB,EAA6B;AAAA;;AACtC,QAAI,CAACb,IAAD,IAASA,KAAKC,MAAL,KAAgB,CAA7B,EAAgC;AAC9B;AACD;;AAED;AACA,QAAIW,mBAAmB,EAAvB;AACA,QAAI+B,MAAMzC,OAAN,IAAiByC,MAAMzC,OAAN,CAAcD,MAAd,GAAuB,CAA5C,EAA+C;AAC7C;AACAW,yBAAmB+B,MAAMzC,OAAzB;AACD,KAHD,MAGO;AACL;AACAU,yBAAmB,KAAKb,UAAL,CAAgBC,IAAhB,CAAnB;AACD;;AAED;AACA,QAAI4C,oBAAoB,EAAxB;AACA,qBAAE7B,IAAF,CAAOf,IAAP,EAAa,UAAC6C,GAAD,EAAS;AACpB,UAAIA,IAAIC,IAAJ,KAAa,OAAjB,EAA0B;AACxB,cAAM,EAACC,SAAS,mEAAV,EAAN;AACD;AACDH,wBAAkBxC,IAAlB,CAAuB,MAAKO,cAAL,CAAoBkC,GAApB,EAAyBjC,gBAAzB,CAAvB;AACD,KALD;;AAOA;AACA,QAAIoC,eAAe,KAAKhB,WAAL,CAAiBY,iBAAjB,CAAnB;AACA/B,UAAMX,OAAN,GAAgB8C,aAAa9C,OAA7B;AACAW,UAAMG,IAAN,GAAagC,aAAahC,IAA1B;AACD;AA9HkB,CAArB;;AAiIA,SAASiC,oBAAT,CAA8BjD,IAA9B,EAAoC2C,KAApC,EAA2C;AACzC,MAAI9B,QAAQ,6BAAZ;;AAEA,MAAI,CAACb,IAAD,IAASA,KAAKC,MAAL,KAAgB,CAA7B,EAAgC;AAC9B,WAAOY,KAAP;AACD;;AAED,MAAIqC,cAActD,aAAa+C,MAAMD,SAAnB,CAAlB;AACA,MAAI,CAACQ,WAAL,EAAkB;AAChB,UAAM,EAACH,SAAS,iBAAiBJ,MAAMD,SAAvB,GAAmC,YAA7C,EAAN;AACD;;AAEDQ,cAAYR,SAAZ,CAAsB1C,IAAtB,EAA4B2C,KAA5B,EAAmC9B,KAAnC;AACA,SAAOA,KAAP;AACD;;QAEOjB,Y,GAAAA,Y;QAAcqD,oB,GAAAA,oB","file":"transformers.js","sourcesContent":["import _ from 'lodash';\nimport {TableModel} from './table_model';\n\nlet transformers = {};\n\ntransformers.table = {\n  description: 'Table',\n  getColumns: function(data) {\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    // Create a list containing the column names from each table\n    let columns = [];\n    _.forEach(data, (table) => {\n      columns.push(table.columns);\n    });\n    // Return the intersection of all column names only returning\n    // those that are present in each table\n    // NOTE: _.intersection([array]) should work here, but appears to be broken\n    return columns.shift().filter(function(v) {\n      return columns.every(function(a) {\n        return a.indexOf(v) !== -1;\n      });\n    });\n  },\n\n  transformTable: function(data, columnsToInclude) {\n    let model = new TableModel();\n\n    // Convert the rows to columns\n    let cellsByColumnIndex = [];\n    _.each(data.columns, () => cellsByColumnIndex.push([]));\n\n    // For every row\n    _.each(data.rows, row => {\n      // And every cell in the row\n      for (let i = 0; i < row.length; i++) {\n        // Append the cell to the appropriate column list\n        cellsByColumnIndex[i].push(row[i]);\n      }\n    });\n\n    // Used when no matching column is found\n    let emptyColumn = new Array(data.rows.length);\n\n    // Now reorder the columns according the list of columns in the panel definition\n    let cellsByPanelColumnIndex = [];\n    for (let j = 0; j < columnsToInclude.length; j++) {\n      let colDef = columnsToInclude[j];\n      // Determine the column's index in the given data\n      let idx = _.findIndex(data.columns, col => {\n        return col === colDef.text || col.text === colDef.text;\n      });\n      if (idx < 0) {\n        // The column does not exist\n        cellsByPanelColumnIndex[j] = emptyColumn;\n        continue;\n      }\n      // Re-order\n      cellsByPanelColumnIndex[j] = cellsByColumnIndex[idx];\n    }\n\n    // Convert the columns back to rows\n    model.columns = columnsToInclude;\n    model.rows = [];\n    for (let k = 0; k < cellsByPanelColumnIndex[0].length; k++) {\n      let row = [];\n      for (let l = 0; l < columnsToInclude.length; l++) {\n        row.push(cellsByPanelColumnIndex[l][k]);\n      }\n      // Preserve the meta-data, if any\n      if (data.rows[k].meta !== undefined) {\n        row.meta = data.rows[k].meta;\n      }\n      model.rows.push(row);\n    }\n    return model;\n  },\n\n  mergeTables: function(tables) {\n    let model = new TableModel();\n    // Use the list of columns from the first table:\n    //  transformTable() will ensure that all tables have the same columns\n    model.columns = tables[0].columns;\n    // Concatenate the rows\n    _.each(tables, table => {\n      model.rows = _.concat(model.rows, table.rows);\n    });\n    // De-duplicate by (source, alarm.id) tuple\n    model.rows = _.uniqBy(model.rows, row => {\n      if (row.meta && row.meta.alarm) {\n        return JSON.stringify({\n          source: row.meta.source,\n          alarmId: row.meta.alarm.id\n        });\n      } else {\n        return row;\n      }\n    });\n    return model;\n  },\n\n  transform: function(data, panel, model) {\n    if (!data || data.length === 0) {\n      return;\n    }\n\n    // Determine the list of columns to include\n    let columnsToInclude = [];\n    if (panel.columns && panel.columns.length > 0) {\n      // One or more columns were specified in the column definition, use these\n      columnsToInclude = panel.columns;\n    } else {\n      // Use all the available columns\n      columnsToInclude = this.getColumns(data);\n    }\n\n    // Transform each of the datasource results individually\n    let transformedTables = [];\n    _.each(data, (dat) => {\n      if (dat.type !== 'table') {\n        throw {message: 'Query result is not in table format, try using another transform.'};\n      }\n      transformedTables.push(this.transformTable(dat, columnsToInclude));\n    });\n\n    // Merge the results and update the model\n    let mergedTables = this.mergeTables(transformedTables);\n    model.columns = mergedTables.columns;\n    model.rows = mergedTables.rows;\n  }\n};\n\nfunction transformDataToTable(data, panel) {\n  let model = new TableModel();\n\n  if (!data || data.length === 0) {\n    return model;\n  }\n\n  let transformer = transformers[panel.transform];\n  if (!transformer) {\n    throw {message: 'Transformer ' + panel.transform + ' not found'};\n  }\n\n  transformer.transform(data, panel, model);\n  return model;\n}\n\nexport {transformers, transformDataToTable};\n"]}