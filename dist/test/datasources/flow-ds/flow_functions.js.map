{"version":3,"sources":["../../../../src/datasources/flow-ds/flow_functions.js"],"names":["index","categories","Combine","Filter","Transform","addFuncDef","funcDef","params","defaultParams","category","push","name","shortName","type","each","funcList","catName","sortBy","FuncInstance","options","def","withDefaultParams","slice","updateText","prototype","render","parameters","map","value","paramType","isNumeric","bind","_hasMultipleParamsInString","strValue","indexOf","optional","updateParam","split","partVal","idx","trim","splice","length","text","join","Gfuncs","isString","message","filteredCategories","functions"],"mappings":"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","file":"flow_functions.js","sourcesContent":["import _ from 'lodash';\nimport $ from 'angular';\n\nlet index = [];\nlet categories = {\n  Combine: [],\n  Filter: [],\n  Transform: []\n};\n\nfunction addFuncDef(funcDef) {\n  funcDef.params = funcDef.params || [];\n  funcDef.defaultParams = funcDef.defaultParams || [];\n\n  if (funcDef.category) {\n    funcDef.category.push(funcDef);\n  }\n  index[funcDef.name] = funcDef;\n  index[funcDef.shortName || funcDef.name] = funcDef;\n}\n\n// Combine\n\naddFuncDef({\n  name: 'topN',\n  category: categories.Combine,\n  params: [{name: \"n\", type: \"int\",}],\n  defaultParams: [10]\n});\n\naddFuncDef({\n  name: 'includeOther',\n  category: categories.Combine\n});\n\n// Filter\n\naddFuncDef({\n  name: 'withExporterNode',\n  category: categories.Filter,\n  params: [{name: \"nodeCriteria\", type: \"string\"}]\n});\n\naddFuncDef({\n  name: 'withIfIndex',\n  category: categories.Filter,\n  params: [{name: \"ifIndex\", type: \"int\"}]\n});\n\n// Transform\n\naddFuncDef({\n  name: 'perSecond',\n  category: categories.Transform\n});\n\naddFuncDef({\n  name: 'toBits',\n  category: categories.Transform\n});\n\naddFuncDef({\n  name: 'negativeEgress',\n  category: categories.Transform\n});\n\naddFuncDef({\n  name: 'negativeIngress',\n  category: categories.Transform\n});\n\naddFuncDef({\n  name: 'asTableSummary',\n  category: categories.Transform\n});\n\naddFuncDef({\n  name: 'combineIngressEgress',\n  category: categories.Transform\n});\n\naddFuncDef({\n  name: 'onlyIngress',\n  category: categories.Transform\n});\n\naddFuncDef({\n  name: 'onlyEgress',\n  category: categories.Transform\n});\n\n_.each(categories, function (funcList, catName) {\n  categories[catName] = _.sortBy(funcList, 'name');\n});\n\nfunction FuncInstance(funcDef, options) {\n  this.def = funcDef;\n  this.params = [];\n\n  if (options && options.withDefaultParams) {\n    this.params = funcDef.defaultParams.slice(0);\n  }\n\n  this.updateText();\n}\n\nFuncInstance.prototype.render = function (/* metricExp */) {\n  return {\n    name: this.def.name,\n    parameters: _.map(this.params, function (value, index) {\n      let paramType = this.def.params[index].type;\n      if (paramType === 'int' || paramType === 'value_or_series' || paramType === 'boolean') {\n        return value;\n      }\n      else if (paramType === 'int_or_interval' && $.isNumeric(value)) {\n        return value;\n      }\n      return value;\n    }.bind(this))\n  };\n};\n\nFuncInstance.prototype._hasMultipleParamsInString = function (strValue, index) {\n  if (strValue.indexOf(',') === -1) {\n    return false;\n  }\n\n  return this.def.params[index + 1] && this.def.params[index + 1].optional;\n};\n\nFuncInstance.prototype.updateParam = function (strValue, index) {\n  // handle optional parameters\n  // if string contains ',' and next param is optional, split and update both\n  if (this._hasMultipleParamsInString(strValue, index)) {\n    _.each(strValue.split(','), function (partVal, idx) {\n      this.updateParam(partVal.trim(), index + idx);\n    }.bind(this));\n    return;\n  }\n\n  if (strValue === '' && this.def.params[index].optional) {\n    this.params.splice(index, 1);\n  }\n  else {\n    this.params[index] = strValue;\n  }\n\n  this.updateText();\n};\n\nFuncInstance.prototype.updateText = function () {\n  if (this.params.length === 0) {\n    this.text = this.def.name + '()';\n    return;\n  }\n\n  let text = this.def.name + '(';\n  text += this.params.join(', ');\n  text += ')';\n  this.text = text;\n};\n\nexport class Gfuncs {\n  static createFuncInstance(funcDef, options) {\n    if (_.isString(funcDef)) {\n      if (!index[funcDef]) {\n        throw {message: 'Method not found ' + name};\n      }\n      funcDef = index[funcDef];\n    }\n    return new FuncInstance(funcDef, options);\n  }\n\n  static getFuncDef(name) {\n    return index[name];\n  }\n\n  static getCategories(/* graphiteVersion */) {\n    let filteredCategories = {};\n    _.each(categories, function (functions, category) {\n      if (functions.length) {\n        filteredCategories[category] = functions;\n      }\n    });\n\n    return filteredCategories;\n  }\n}\n"]}