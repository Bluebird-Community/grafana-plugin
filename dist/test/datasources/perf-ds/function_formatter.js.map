{"version":3,"sources":["../../../../src/datasources/perf-ds/function_formatter.js"],"names":["ARGUMENT_MATCH","isString","value","String","getLast","arr","Array","isArray","length","undefined","FunctionFormatter","label","_process","brackets","parenthesized","parenthesize","map","entry","arguments","getArguments","console","log","parenthesizeWithArguments","filter","name","args","argsString","split","replacements","ret","forEach","token","hasOwnProperty","apply","join","metadata","replace","nodeToLabel","nodeCriteria","node","_getNodeFromCriteria","resourceToLabel","criteriaOrResourceId","partialResourceId","resource","_getResource","resourceToName","resourceToInterface","match","matcher","skip","arg","index","prev","next","push","exec","prefix","startsWith","replacement","_flatten","result","res","trim","Error","nodeId","foreignSource","foreignId","indexOf","parseInt","_getNodeFromMetadata","nodes","id","resources","_getResourceFromCriteria","resourceCriteria","nodeCriterias","c","criteria"],"mappings":"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","file":"function_formatter.js","sourcesContent":["const ARGUMENT_MATCH = /\\s*,\\s*/;\n\nimport parse from '../../parenthesis/index';\n\nconst isString = (value) => {\n    return typeof value === 'string' || value instanceof String;\n};\n\nconst getLast = (arr) => {\n    if (arr) {\n        if (Array.isArray(arr) && arr.length > 0) {\n            return arr[arr.length - 1];\n        }\n    }\n    return undefined;\n};\n\nexport class FunctionFormatter {\n    /**\n     * Convert the provided label into an array containing a mix of string values\n     * and function definitions for replacement.\n     */\n    static parenthesize(label) {\n        return FunctionFormatter._process(parse(label, {\n            brackets: ['()']\n        }));\n    }\n\n    /**\n     * Preprocess the parenthesized output so that format object arguments are parameterized\n     */\n    static parenthesizeWithArguments(label) {\n        const parenthesized = FunctionFormatter.parenthesize(label);\n        return parenthesized.map(entry => {\n            if (entry && entry.arguments) {\n                if (entry.arguments.length < 2) {\n                    entry.arguments = FunctionFormatter.getArguments(entry.arguments[0]);\n                } else {\n                    console.log('unexpected arguments, expected a single string:', entry);\n                }\n            }\n            return entry;\n        });\n    }\n\n    /**\n     * Given a label, return the list of potential functions found in it.\n     */\n    static findFunctions(label) {\n        return FunctionFormatter.parenthesizeWithArguments(label).filter(entry => entry && entry.name !== undefined);\n    }\n\n    /**\n     * Given an argument string, return a list of arguments.\n     */\n    static getArguments(args) {\n        const argsString = (args === undefined || args === null)? '' : args;\n        if (argsString.length === 0) {\n            return [];\n        }\n        const split = argsString.split(ARGUMENT_MATCH);\n        return Array.isArray(split) ? split : [split];\n    }\n\n    /**\n     * Given a label, replace instances of the functions in the replacements object.\n     * @param {string} label - the label string\n     * @param {*} replacements - an object of function names and their callbacks\n     */\n    static replace(label, replacements) {\n        const parenthesized = FunctionFormatter.parenthesizeWithArguments(label);\n\n        let ret = '';\n        parenthesized.forEach(token => {\n            if (isString(token)) {\n                // just a regular scalar\n                ret += token;\n            } else if (token.name) {\n                // potential function, check against replacements\n                if (replacements && replacements.hasOwnProperty(token.name)) {\n                    ret += replacements[token.name].apply(replacements[token.name], token.arguments);\n                } else {\n                    // not a matching function, just put it back\n                    ret += token.name + '(';\n                    if (token.arguments) {\n                        ret += token.arguments.join(', ');\n                    }\n                    ret += ')';\n                }\n            } else {\n                console.log('this should not happen... token=', token);\n            }\n        });\n        return ret;\n    }\n\n    /**\n     * Given a label and a set of OpenNMS measurements metadata, replace default\n     * functions like `nodeToLabel` and `resourceToName`.\n     * @param {string} label - the label string\n     * @param {*} replacements - an object of function names and their callbacks\n     */\n    static format(label, metadata) {\n        return FunctionFormatter.replace(label, {\n            nodeToLabel: (nodeCriteria) => {\n                const node = FunctionFormatter._getNodeFromCriteria(metadata, nodeCriteria);\n                if (node) {\n                    return node.label;\n                }\n                return nodeCriteria;\n            },\n            resourceToLabel: (criteriaOrResourceId, partialResourceId) => {\n                const resource = FunctionFormatter._getResource(metadata, criteriaOrResourceId, partialResourceId);\n                if (resource) {\n                    return resource.label;\n                }\n                return partialResourceId ? [criteriaOrResourceId, partialResourceId].join('.') : criteriaOrResourceId;\n            },\n            resourceToName: (criteriaOrResourceId, partialResourceId) => {\n                const resource = FunctionFormatter._getResource(metadata, criteriaOrResourceId, partialResourceId);\n                if (resource) {\n                    return resource.name;\n                }\n                return partialResourceId ? [criteriaOrResourceId, partialResourceId].join('.') : criteriaOrResourceId;\n            },\n            resourceToInterface: (criteriaOrResourceId, partialResourceId) => {\n                const resource = FunctionFormatter._getResource(metadata, criteriaOrResourceId, partialResourceId);\n                if (resource) {\n                    let match = resource.name.match(/^(\\w+)/);\n                    if (!match) {\n                        match = resource.label.match(/^(\\w+)/);\n                    }\n                    if (match) {\n                        return match[1];\n                    }\n                }\n                return partialResourceId ? [criteriaOrResourceId, partialResourceId].join('.') : criteriaOrResourceId;\n            }\n        });\n    }\n\n    /**\n     * Process the raw output of `parenthesis.parse` to detect functions.\n     */\n    static _process(args) {\n        const ret = [];\n        const matcher = /^(.*?)(\\w+?)\\($/;\n        let skip = false;\n        args.forEach((arg, index) => {\n            if (skip) {\n                skip = false;\n                return;\n            }\n            const prev = ret.length ? ret[ret.length - 1] : undefined;\n            const next = args[index + 1];\n\n            let match;\n            if (Array.isArray(arg)) {\n                ret.push(FunctionFormatter._process(arg));\n            } else if ((match = matcher.exec(arg)) !== null) {\n                let prefix = match[1];\n                if (prefix && prefix.length > 0) {\n                    if (prefix.startsWith(')') && prev && prev.name) {\n                        prefix = prefix.replace(/^\\)/, '');\n                    }\n                    ret.push(prefix);\n                }\n                ret.push({\n                    name: match[2],\n                    arguments: FunctionFormatter._process(next)\n                });\n                skip = true;\n            } else if (isString(arg) && arg.startsWith(')') && prev && prev.name) {\n                const replacement = arg.replace(/^\\)/, '');\n                if (replacement.length > 0) {\n                    ret.push(replacement);\n                }\n            } else {\n                ret.push(arg);\n            }\n        });\n        return FunctionFormatter._flatten(ret);\n    }\n\n    /**\n     * Combine string values in processed parenthesized output (from `_process`)\n     * so that we end up with a flat array of scalar strings and function replacements.\n     */\n    static _flatten(args) {\n        let ret = [];\n        args.forEach((arg) => {\n            if (isString(arg)) {\n                if (arg.length === 0) {\n                    return;\n                }\n                const prev = getLast(ret);\n                // argument is a string-part of the parsed label\n                if (isString(prev)) {\n                    ret[ret.length - 1] += arg;\n                } else {\n                    ret.push(arg);\n                }\n            } else if (arg && arg.arguments) {\n                // argument is a function, whose arguments may be flattenable as well\n                arg.arguments = FunctionFormatter._flatten(arg.arguments);\n                ret.push(arg);\n            } else if (Array.isArray(arg)) {\n                // argument is sub-parens that need further flattening\n                const result = FunctionFormatter._flatten(arg);\n                result.forEach((res) => {\n                    const prev = getLast(ret);\n                    if (isString(res)) {\n                        if (res.trim().length === 0) {\n                            return;\n                        }\n                        if (isString(prev)) {\n                            ret[ret.length - 1] += res;\n                        } else {\n                            ret.push(res);\n                        }\n                    } else if (res && res.arguments) {\n                        // argument is a function\n                        ret.push(res);\n                    } else {\n                        throw new Error('cannot reach here');\n                    }\n                });\n            } else {\n                throw new Error('cannot reach here');\n            }\n        });\n        return ret;\n    }\n\n    static _getNodeFromCriteria(metadata, nodeCriteria) {\n        let nodeId, foreignSource, foreignId;\n        if (nodeCriteria && nodeCriteria.indexOf(':') > 0) {\n            [foreignSource, foreignId] = nodeCriteria.split(':');\n        } else {\n            nodeId = parseInt(nodeCriteria, 10);\n        }\n        return FunctionFormatter._getNodeFromMetadata(metadata, nodeId, foreignSource, foreignId);\n    }\n\n    static _getNodeFromMetadata(metadata, nodeId, foreignSource, foreignId) {\n        if (metadata && metadata.nodes) {\n            const ret = metadata.nodes.filter((node) => {\n                return (nodeId !== undefined && node.id === nodeId) ||\n                (foreignSource !== undefined && foreignId !== undefined &&\n                    node['foreign-source'] === foreignSource && node['foreign-id'] === foreignId);\n            })[0];\n            if (ret !== undefined) {\n                return ret;\n            }\n        }\n        //console.warn('Unable to locate node ' + [nodeId, foreignSource, foreignId].join(',') + ' in metadata.', metadata);\n        return null;\n    }\n\n    static _getResource(metadata, criteriaOrResourceId, partialResourceId) {\n        if (partialResourceId === undefined) {\n            for (const resource of metadata.resources) {\n                if (resource.id === criteriaOrResourceId) {\n                    return resource;\n                }\n            }\n        } else {\n            const node = FunctionFormatter._getNodeFromCriteria(metadata, criteriaOrResourceId);\n            if (node) {\n                const resource = FunctionFormatter._getResourceFromCriteria(metadata, partialResourceId, 'node[' + node['foreign-source'] + ':' + node['foreign-id'] + ']', 'node[' + node.id + ']');\n                if (resource) {\n                    return resource;\n                }\n            }\n        }\n        //console.warn('Unable to locate resource ' + [criteriaOrResourceId,partialResourceId].join('.') + ' in metadata.', metadata);\n        return null;\n    }\n\n    static _getResourceFromCriteria(metadata, resourceCriteria, ...nodeCriterias) {\n        if (metadata && metadata.resources) {\n            const ret = metadata.resources.filter((resource) => {\n                if (resource.id === resourceCriteria) return true;\n                for (const criteria of nodeCriterias.map(c => c + '.' + resourceCriteria)) {\n                    if (resource.id === criteria) {\n                        return true;\n                    }\n                }\n                return false;\n            })[0];\n            if (ret !== undefined) {\n                return ret;\n            }\n        }\n        //console.warn('Unable to locate resource ' + resourceCriteria + ' in metadata.', metadata);\n        return null;\n    }\n}"]}